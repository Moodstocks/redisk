{"name":"Redisk","body":"## Warning\r\n\r\nDO NOT USE IN PRODUCTION. I REPEAT: DO NOT USE IN PRODUCTION (OR FOR ANYTHING IMPORTANT).\r\n\r\nThis is a hack developed for a hackathon. We intend to continue working on it and release it someday but currently the project is definitely not in a usable state, except for demo / test purpose.\r\n\r\n## What it is?\r\n\r\nredisk is an embeddable, portable (hopefully), disk-persistent [Redis](http://redis.io/) compatible C library\r\nfeaturing:\r\n\r\n* a brand new [Redis protocol](http://redis.io/topics/protocol) parser written with the [Ragel](http://www.complang.org/ragel/) state machine compiler,\r\n* a dedicated server layer written on-top of [libuv](https://github.com/joyent/libuv),\r\n* an extensible backend layer via a Redis API C-based skeleton,\r\n* [Tokyo Cabinet](http://fallabs.com/tokyocabinet/) as default backend.\r\n\r\nYou can use it with or without the server-stack, i.e in an embedded fashion by\r\ntaking benefit of the `rk_tcdb_t` C programmatic API.\r\n\r\nThe backend layer has been inspired from another similar project called [lycadb](https://github.com/nicolasff/lycadb) by [yowgi](http://twitter.com/yowgi).\r\n\r\n## Use cases\r\n\r\nIt should be interesting for you if you want to run/embedd Redis e.g:\r\n\r\n* on a mobile device with limited RAM, e.g.:\r\n  * as an alternative embedded data store, to manipulate data the Redis way,\r\n  * to implement a general purpose on-disk URL cache,\r\n  * to implement a persistent store used to collect client-side logs, tasks, etc to be handled asynchronously,\r\n* on a development machine on which a production dataset may not fit in memory,\r\n* on a production machine:\r\n  * as a backend to collect a very large amount of logs (e.g. see [Fluent event collector](http://fluentd.org/doc/overview.html)),\r\n  * as a slave dedicated to disk-based replication.\r\n\r\n## Install\r\n\r\nFirst you need to install the [Ragel](http://www.complang.org/ragel/) compiler. If you are on OS X and use [homebrew](https://github.com/mxcl/homebrew) just type:\r\n\r\n    brew install ragel\r\n    \r\nThen clone/get the dependencies ([libuv](https://github.com/joyent/libuv) and [Tokyo Cabinet 1.4.47](http://fallabs.com/tokyocabinet/)) by typing:\r\n\r\n    make get-deps\r\n    \r\nAt last compile `redisk` by typing:\r\n\r\n    make\r\n\r\n> **TIP** for a recap type `make help`.\r\n    \r\n## Usage\r\n\r\nOn a terminal, start the `redisk` server on the port of your choice (e.g. 1981) by typing:\r\n\r\n    ./redisk 1981\r\n    listening on port 1981\r\n    \r\nYou can then use the `redis-cli` command line client to interact with `redisk`, e.g. within another terminal:\r\n\r\n    $ redis-cli -p 1981 SET mykey Hello\r\n    OK\r\n    $ redis-cli -p 1981 GET mykey\r\n    \"Hello\"\r\n\r\n## C API Example Code\r\n\r\n    #include <stdio.h>\r\n    #include <stdlib.h>\r\n    #include <stdbool.h>\r\n    #include <stdint.h>\r\n    \r\n    #include \"tcdb.h\"\r\n    \r\n    int main(int argc, char **argv) {\r\n        rk_tcdb_t *db;\r\n        bool diag;\r\n        char *res;\r\n        int len;\r\n        \r\n        /* Initialize the database */\r\n        db = rk_tcdb_new();\r\n        if (!rk_tcdb_open(db, \"rk.db\")) {\r\n            fprintf(stderr, \"open error\\n\");\r\n        }\r\n        \r\n        /* SET key value */\r\n        diag = rk_tcdb_set(db, \"mykey\", 5, \"Hello\", 5);\r\n        printf(\" SET mykey \\\"Hello\\\" -> %s\\n\", diag ? \"OK\" : \"(error)\");\r\n        \r\n        /* GET key */\r\n        res = rk_tcdb_get(db, \"mykey\", 5, &len);\r\n        printf(\" GET mykey -> %s\\n\", res ? res : \"(nil)\");\r\n        \r\n        /* Cleanup */\r\n        if (!rk_tcdb_close(db)) {\r\n            fprintf(stderr, \"close error\\n\");\r\n        }\r\n        rk_tcdb_free(db);\r\n        if (res) free(res);\r\n        \r\n        return 0;\r\n    }\r\n\r\n## Contributing\r\n\r\nThe project is still very young and has many room for improvements, e.g:\r\n\r\n* write the missing Redis API commands (e.g. [LINDEX](http://redis.io/commands/lindex), [SINTER](http://redis.io/commands/sinter), etc),\r\n* extend C API to support variadic commands (e.g. [HMGET](http://redis.io/commands/hmget)),\r\n* introduce error codes to properly bubble up errors,\r\n* write documentation,\r\n* write tests,\r\n* plug in another DBM backend, e.g:\r\n  * [sqlite](http://www.sqlite.org/),\r\n  * [Berkeley DB](http://www.oracle.com/technology/products/berkeley-db),\r\n  * [leveldb](http://code.google.com/p/leveldb/),\r\n  * etc\r\n* improve the build system,\r\n* packaging, i.e create a static library that wraps the backend layer to make it easy to embed,\r\n* introduce parameters to tune things up (e.g Tokyo bucket number, cache size, etc),\r\n* support [zsets](http://redis.io/commands#sorted_set) (low priority),\r\n* etc\r\n\r\nKnown bugs:\r\n\r\n* probably lots of memory leaks & issues to fix with Valgrind\r\n\r\nIf you enjoy it, feel free to fork and send your pull requests!\r\n\r\n## Hack Day Paris\r\n\r\nThis project has been created at [Hack Day Paris](http://hackdayparis.org/) - a Paris based 40-hour marathon of hyper-intensive design and development.\r\n\r\n## Authors\r\n\r\n[Pierre Chapuis](http://twitter.com/pchapuis) & [CÃ©dric Deltheil](http://about.me/deltheil).\r\n","tagline":"Lightweight, embeddable, disk-persistent Redis-compatible library.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}